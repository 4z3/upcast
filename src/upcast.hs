{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE ImplicitParams #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module Main where

import           Prelude hiding (sequence)

import           Control.Monad.Catch (MonadCatch)
import           Control.Monad.Error.Class (MonadError)
import qualified Control.Monad.Trans.AWS as AWS

import           Data.Aeson
import qualified Data.ByteString.Char8 (ByteString)
import qualified Data.ByteString.Char8 as B8
import           Data.List (intercalate)
import qualified Data.Map as Map
import           Data.Maybe (catMaybes, fromMaybe, isJust)
import           Data.Monoid
import           Data.Text (Text(..))
import qualified Data.Text as T
import           Data.Traversable

import           Options.Applicative
import           System.Directory (removeFile)
import           System.Environment (setEnv)
import           System.FilePath.Posix
import           System.Posix.Env (getEnvDefault)
import           System.Posix.Files (readSymbolicLink)

import           Network.AWS.Types as AWS

import           Upcast.Command
import           Upcast.DeployCommands
import           Upcast.Environment
import           Upcast.IO
import           Upcast.Infra
import           Upcast.Infra.AmazonkaTypes
import           Upcast.Infra.Match
import           Upcast.Infra.NixTypes
import           Upcast.Install
import           Upcast.Monad
import           Upcast.Nix
import           Upcast.Temp
import           Upcast.Types

evalInfraContext :: InfraCli -> NixContext -> IO InfraContext
evalInfraContext InfraCli{..} nix@NixContext{nix_expressionFile=file} = do
  info <- fgconsume_ (nixInfraInfo nix)
  value <- expectRight $ return $ nixInfras info
  return InfraContext{ inc_expressionFile = file
                     , inc_stateFile = fromMaybe (replaceExtension file "store") infraCli_stateFile
                     , inc_infras = value
                     }

icontext :: InfraCli -> IO InfraContext
icontext infraCli@InfraCli{..} =
  nixContext infraCli_expressionFile >>= evalInfraContext infraCli

infra :: InfraCli -> IO [Machine]
infra = icontext >=> evalInfra

infraDump :: InfraCli -> IO ()
infraDump = icontext >=> print . inc_infras

infraDebug :: InfraCli -> IO ()
infraDebug = icontext >=> debugEvalInfra >=> const (return ())

infraScan :: InfraCli -> IO ()
infraScan = icontext >=> go >=> pprint . object
  where
    go InfraContext{inc_infras=infras@Infras{..}} = do
      let match ::
            (CanMatch a, Applicative f, MonadCatch f, MonadError AWS.Error f, AWS.MonadAWS f)
            => Attrs a -> f (Attrs (Either DiscoveryError ResourceId))
          match = traverse (`matchTags` [("realm", infraRealmName)])

          matchWithName ::
            (CanMatch a, Applicative f, MonadCatch f, MonadError AWS.Error f, AWS.MonadAWS f)
            => Attrs a -> f (Attrs (Either DiscoveryError ResourceId))
          matchWithName = Map.traverseWithKey
                         (\k v -> matchTags v [("realm", infraRealmName), ("Name", k)])

      let region = readRegion (validateRegion infras)
      env <- AWS.getEnv region AWS.Discover
      expectRight $ AWS.runAWST env $
        sequence [ ("vpc" .=)      <$> matchWithName infraEc2vpc
                 , ("subnet" .=)   <$> match infraEc2subnet
                 , ("sg" .=)       <$> match infraEc2sg
                 , ("keypair" .=)  <$> match infraEc2keypair
                 , ("ebs" .=)      <$> match infraEbs
                 , ("instance" .=) <$> matchWithName infraEc2instance
                 , ("elb" .=)      <$> match infraElb
                 ]

buildRemote :: BuildRemoteCli -> IO ()
buildRemote BuildRemoteCli{..} =
  nixContext brc_expressionFile >>= go >>= B8.putStrLn
  where
    remote = Remote Nothing brc_builder

    ssh_ = let ?sshConfig = Nothing in ssh
    fwd = fgrunDirect . ssh_ . forward remote
    copy = let ?sshConfig = Nothing in nixCopyClosureTo

    go :: NixContext -> IO B8.ByteString
    go NixContext{..} = do
      drv <- fgtmp $ nixInstantiate nix_args brc_attribute nix_expressionFile

      let query = args ["nix-store", "-qu", drv]

      srsly "nix-copy-closure failed" . fgrunDirect $ copy brc_builder drv
      srsly "realise failed" . fwd $ nixRealise drv
      out <- fgconsume_ . ssh_ $ Cmd remote query "query"
      when brc_cat $ do
        fwd $ Cmd Local (args ["cat", toString out]) "cat"
        return ()
      when (isJust brc_installProfile) $ do
        let Just prof = brc_installProfile
        fwd $ nixSetProfile prof (B8.unpack out)
        return ()
      return out

sshConfig :: InfraCli -> IO ()
sshConfig = infra >=> out . mconcat . fmap config
  where
    out s = putStrLn prefix >> putStrLn s

    identity (Just file) = args ["IdentityFile", toString file]
    identity Nothing = ""

    prefix = unlines
             [ "# hello!"
             , "# this file is automatically generated using `upcast infra'"
             , "#"
             , "UserKnownHostsFile=/dev/null"
             , "StrictHostKeyChecking=no"
             ]

    config Machine{..} = unlines
      [ args ["Host", toString m_hostname]
      , args ["#", toString m_instanceId]
      , args ["HostName", toString m_publicIp]
      , "User root"
      , "ControlMaster auto"
      , "ControlPath ~/.ssh/master-%r@%h:%p"
      , "ForwardAgent yes"
      , "ControlPersist 60s"
      , identity m_keyFile
      , ""
      ]

machine2nix :: Machine -> String
machine2nix Machine{..} = unlines
  [ args [ dquote m_hostname, "= {" ]
  , mconcat ["instance-id = ", toString m_instanceId, ";"]
  , mconcat ["public-ip = ", toString m_publicIp, ";"]
  , mconcat ["private-ip = ", toString m_privateIp, ";"]
  , mconcat ["key-file = ", keyFile, ";"]
  , "};"
  ]
  where
    keyFile = case m_keyFile of
               Nothing -> "null"
               Just x -> squote x

infraNix :: InfraCli -> IO ()
infraNix = infra >=> out . intercalate "\n" . fmap machine2nix
  where
    out s = putStrLn prefix >> putStrLn s >> putStrLn suffix

    prefix = unlines
             [ "#"
             , "# this file is automatically generated using `upcast infra-nix'"
             , "#"
             , "{"
             , "  instances = {"
             ]

    suffix = "  };\n}\n"

printNixPath :: IO ()
printNixPath = do
  Just p <- nixPath
  putStrLn p

fgtmp :: (FilePath -> Command Local) -> IO FilePath
fgtmp f = do
  tmp <- randomTempFileName "fgtmp."
  let cmd@(Cmd _ _ tag) = f tmp
  expect ExitSuccess (tag <> " failed") $ fgrunDirect cmd
  dest <- readSymbolicLink tmp
  removeFile tmp
  return dest

main :: IO ()
main = do
    hSetBuffering stderr LineBuffering
    join $ customExecParser prefs opts
  where
    prefs = ParserPrefs { prefMultiSuffix = ""
                        , prefDisambiguate = True
                        , prefShowHelpOnError = True
                        , prefBacktrack = True
                        , prefColumns = 80
                        }

    exp = metavar "<expression file>"

    opts = subparser cmds `info` header "upcast - infrastructure orchestratrion"

    cmds = command "infra"
           (sshConfig <$> infraCliArgs `info`
            progDesc "evaluate infrastructure and output ssh_config(5)")

        <> command "infra-tree"
           (infraDump <$> infraCliArgs `info`
            progDesc "dump infrastructure tree in json format")

        <> command "infra-debug"
           (infraDebug <$> infraCliArgs `info`
            progDesc "evaluate infrastructure in debug mode")

        <> command "infra-nix"
           (infraNix <$> infraCliArgs `info`
            progDesc "evaluate infrastructure and print the nix description")

        <> command "infra-scan"
           (infraScan <$> infraCliArgs `info`
            progDesc "scan for existing resources ignoring the state file")

        <> command "build-remote"
           (buildRemote <$> buildRemoteCli `info`
            progDesc "forward nix-build to a remote host")

        <> command "nix-path"
           (pure printNixPath `info`
            progDesc "print effective path to upcast nix expressions")

        <> command "install"
           ((install fgrunDirect) <$> installCli `info`
            progDesc "copy a store path closure and set it to a profile")

    infraCliArgs = InfraCli
      <$> optional (strOption
                    (long "state"
                     <> short 's'
                     <> metavar "FILE"
                     <> help "use FILE as state file"))
      <*> argument str exp

    installCli = InstallCli
      <$> strOption (long "target"
                     <> short 't'
                     <> metavar "ADDRESS"
                     <> help "SSH-accessible host with Nix")
      <*> optional (strOption
                    (long "profile"
                     <> short 'p'
                     <> metavar "PROFILE"
                     <> help "set STORE_PATH to PROFILE (otherwise system)"))
      <*> optional (strOption
                    (long "ssh-config"
                     <> short 'c'
                     <> metavar "FILE"
                     <> help "use FILE as ssh_config(5)"))
      <*> optional (strOption
                    (long "pull"
                     <> short 'f'
                     <> metavar "FROM"
                     <> help "pull store paths from host"))
      <*> argument str (metavar "STORE_PATH")

    buildRemoteCli = BuildRemoteCli
      <$> strOption (long "target"
                    <> short 't'
                    <> metavar "ADDRESS"
                    <> help "SSH-accessible host with Nix")
      <*> optional (strOption (short 'A'
                     <> metavar "ATTRIBUTE"
                     <> help "build a specific attribute in the expression file"))
      <*> switch (long "print" <> short 'p' <> help "cat the derivation output file after build")
      <*> optional (strOption (short 'i'
                     <> metavar "PROFILE"
                     <> help "set the output store path to PROFILE on the target"))
      <*> argument str exp
