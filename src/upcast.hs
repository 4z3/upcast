{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE ImplicitParams #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module Main where

import           Prelude hiding (sequence)

import           Control.Monad.Catch (MonadCatch)
import           Control.Monad.Error.Class (MonadError)

import           Data.Aeson
import           Data.ByteString.Char8 (ByteString)
import qualified Data.ByteString.Char8 as B8
import           Data.List (intercalate, intersperse)
import qualified Data.Map as Map
import           Data.Maybe (isJust)
import           Data.Monoid (mconcat)
import           Data.Text (Text(..))
import qualified Data.Text as T
import           Data.Traversable (sequence, traverse)

import           Options.Applicative

import qualified Control.Monad.Trans.AWS as AWS
import           Network.AWS.Types as AWS

import           Upcast.Shell hiding ((<>))
import           Upcast.Deploy (nixCopyClosureTo, nixRealise, nixSetProfile, nixSystemProfile)
import           Upcast.Environment (nixPath, nixContext, icontext, nixInstantiate)
import           Upcast.IO
import           Upcast.Infra
import           Upcast.Infra.AmazonkaTypes (readRegion)
import           Upcast.Infra.Match
import           Upcast.Infra.NixTypes
import           Upcast.Install (install)
import           Upcast.Monad
import           Upcast.Types

infra :: InfraCli -> IO [Machine]
infra = icontext >=> evalInfra

infraDump :: InfraCli -> IO ()
infraDump = icontext >=> print . inc_infras

infraDebug :: InfraCli -> IO ()
infraDebug = icontext >=> debugEvalInfra >=> const (return ())

infraScan :: InfraCli -> IO ()
infraScan = icontext >=> go >=> pprint . object
  where
    go InfraContext{inc_infras=infras@Infras{..}} = do
      let match ::
            (CanMatch a, Applicative f, MonadCatch f, MonadError AWS.Error f, AWS.MonadAWS f)
            => Attrs a -> f (Attrs (Either DiscoveryError ResourceId))
          match = traverse (`matchTags` [("realm", infraRealmName)])

          matchWithName ::
            (CanMatch a, Applicative f, MonadCatch f, MonadError AWS.Error f, AWS.MonadAWS f)
            => Attrs a -> f (Attrs (Either DiscoveryError ResourceId))
          matchWithName = Map.traverseWithKey
                         (\k v -> matchTags v [("realm", infraRealmName), ("Name", k)])

      let region = readRegion (validateRegion infras)
      env <- AWS.getEnv region AWS.Discover
      expectRight $ AWS.runAWST env $
        sequence [ ("vpc" .=)      <$> matchWithName infraEc2vpc
                 , ("subnet" .=)   <$> match infraEc2subnet
                 , ("sg" .=)       <$> match infraEc2sg
                 , ("keypair" .=)  <$> match infraEc2keypair
                 , ("ebs" .=)      <$> match infraEbs
                 , ("instance" .=) <$> matchWithName infraEc2instance
                 , ("elb" .=)      <$> match infraElb
                 ]

buildRemote :: BuildRemoteCli -> IO ()
buildRemote BuildRemoteCli{..} =
  nixContext brc_expressionFile >>= go >>= B8.putStrLn
  where
    ssh_ = ssh brc_builder []
    fwd = fgrunDirect . ssh_
    copy = let ?sshConfig = Nothing in nixCopyClosureTo

    go :: NixContext -> IO ByteString
    go NixContext{..} = do
      drv <- fgtmp $ nixInstantiate nix_args brc_attribute nix_expressionFile

      srsly "nix-copy-closure failed" . fgrunDirect $ copy brc_builder drv
      srsly "realise failed" . fwd $ nixRealise drv
      out <- fgconsume_ . ssh_ $ exec "nix-store" ["-qu", drv]
      when brc_cat $ do
        fwd $ exec "cat" [toString out]
        return ()
      when (isJust brc_installProfile) $ do
        let Just prof = brc_installProfile
        fwd $ nixSetProfile prof (B8.unpack out)
        return ()
      return out

sshConfig :: InfraCli -> IO ()
sshConfig = infra >=> out . mconcat . fmap config
  where
    out s = putStrLn prefix >> putStrLn s

    identity (Just file) = args ["IdentityFile", toString file]
    identity Nothing = ""

    prefix = unlines [ "# hello!"
                     , "# this file is automatically generated using `upcast infra'"
                     , "#"
                     , "UserKnownHostsFile=/dev/null"
                     , "StrictHostKeyChecking=no"
                     ]

    args :: [String] -> String
    args = mconcat . intersperse " "

    config Machine{..} = unlines [ args ["Host", toString m_hostname]
                                 , args ["#", toString m_instanceId]
                                 , args ["HostName", toString m_publicIp]
                                 , "User root"
                                 , "ControlMaster auto"
                                 , "ControlPath ~/.ssh/master-%r@%h:%p"
                                 , "ForwardAgent yes"
                                 , "ControlPersist 60s"
                                 , identity m_keyFile
                                 , ""
                                 ]


infraNix :: InfraCli -> IO ()
infraNix = infra >=> out . intercalate "\n" . fmap machine2nix
  where
    out s = putStrLn prefix >> putStrLn s >> putStrLn suffix

    prefix = unlines [ "#"
                     , "# this file is automatically generated using `upcast infra-nix'"
                     , "#"
                     , "{"
                     , "  instances = {"
                     ]

    suffix = "  };\n}\n"

    machine2nix Machine{..} = unlines
      [ mconcat [ "\"", toString m_hostname, "\"= {" ]
      , mconcat ["instance-id = ", toString m_instanceId, ";"]
      , mconcat ["public-ip = ", toString m_publicIp, ";"]
      , mconcat ["private-ip = ", toString m_privateIp, ";"]
      , mconcat ["key-file = ", toString keyFile, ";"]
      , "};"
      ]
      where
        keyFile = case m_keyFile of
                   Nothing -> "null"
                   Just x -> "'" <> x <> "'"

printNixPath :: IO ()
printNixPath = nixPath >>= putStrLn

main :: IO ()
main = do
    hSetBuffering stderr LineBuffering
    join $ customExecParser prefs opts
  where
    prefs = ParserPrefs { prefMultiSuffix = ""
                        , prefDisambiguate = True
                        , prefShowHelpOnError = True
                        , prefBacktrack = True
                        , prefColumns = 80
                        }

    exp = metavar "<expression file>"

    opts = subparser cmds `info` header "upcast - infrastructure orchestratrion"

    cmds = command "infra"
           (sshConfig <$> infraCliArgs `info`
            progDesc "evaluate infrastructure and output ssh_config(5)")

        <> command "infra-tree"
           (infraDump <$> infraCliArgs `info`
            progDesc "dump infrastructure tree in json format")

        <> command "infra-debug"
           (infraDebug <$> infraCliArgs `info`
            progDesc "evaluate infrastructure in debug mode")

        <> command "infra-nix"
           (infraNix <$> infraCliArgs `info`
            progDesc "evaluate infrastructure and print the nix description")

        <> command "infra-scan"
           (infraScan <$> infraCliArgs `info`
            progDesc "scan for existing resources ignoring the state file")

        <> command "build-remote"
           (buildRemote <$> buildRemoteCli `info`
            progDesc "forward nix-build to a remote host")

        <> command "nix-path"
           (pure printNixPath `info`
            progDesc "print effective path to upcast nix expressions")

        <> command "install"
           (install <$> installCli `info`
            progDesc "copy a store path closure and set it to a profile")

    infraCliArgs = InfraCli
      <$> optional (strOption
                    (long "state"
                     <> short 's'
                     <> metavar "FILE"
                     <> help "use FILE as state file"))
      <*> argument str exp

    installCli = Install
      <$> (Remote <$> strOption (long "target"
                                 <> short 't'
                                 <> metavar "ADDRESS"
                                 <> help "SSH-accessible host with Nix"))
      <*> (strOption (long "profile"
                      <> short 'p'
                      <> metavar "PROFILE"
                      <> help "set STORE_PATH to PROFILE (otherwise system)")
           <|> pure nixSystemProfile)
      <*> optional (strOption
                    (long "ssh-config"
                     <> short 'c'
                     <> metavar "FILE"
                     <> help "use FILE as ssh_config(5)"))
      <*> (Pull <$> strOption (long "pull"
                               <> short 'f'
                               <> metavar "FROM"
                               <> help "pull store paths from host")
           <|> pure Push)
      <*> argument str (metavar "STORE_PATH")

    buildRemoteCli = BuildRemoteCli
      <$> strOption (long "target"
                    <> short 't'
                    <> metavar "ADDRESS"
                    <> help "SSH-accessible host with Nix")
      <*> optional (strOption (short 'A'
                     <> metavar "ATTRIBUTE"
                     <> help "build a specific attribute in the expression file"))
      <*> switch (long "print" <> short 'p' <> help "cat the derivation output file after build")
      <*> optional (strOption (short 'i'
                     <> metavar "PROFILE"
                     <> help "set the output store path to PROFILE on the target"))
      <*> argument str exp
